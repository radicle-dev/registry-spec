\section{Transactions}
\label{s:transactions}

All transactions on the registry take the form $\tx{transaction}{arg_1, \ldots,
arg_n}$, where $arg_1, \ldots arg_n$ are the \emph{inputs} and $\sigma$ is the
\textsf{EdDSA} signature of the author of the transaction. Transactions always
have an \emph{author} and an \emph{origin} (formally $\alpha$), which is the
author's account.

Transactions can be uniquely identified by their \emph{hash}. The set of all
\emph{known} transactions is $\txs$ (the ``ledger''), and the set of all known
transaction hashes is $\field{\txs}{hash}$.

\section{Accounts}
An account $A$ is a tuple:
\[
    A = \tuple{\field{A}{id}, \field{A}{nonce}, \field{A}{bal}}
\]

\spec{
    \definition
    \begin{itemize}
        \item $\field{A}{id}$ is the unique account identifier obtained by hashing
            the account owner's public key,
        \item $\field{A}{nonce}$ is a number which starts at $0$ and is incremented
            every time a transaction originates from this account.
        \item $\field{A}{bal}$ is the account's balance in the smallest denomination,
            and $\field{A}{bal} \in \nat_{\geq 0}$.
    \end{itemize}}
The set of all accounts is $\accounts$. Accounts are never created or destroyed,
rather, if they have never been used to transact, they have an initial state of:
\[
    A = \tuple{\field{A}{id}, 0, 0}
\]
Hence, for all valid account ids, there exists an account with that id. In other
words, $\forall a \in \field{A}{id} (A \in \accounts)$.

Note that accounts can \emph{never be removed}, since that would violate the
invariant that nonces are only ever incremented, and removing an account is
equivalent to setting $\field{A}{nonce}$ and $\field{A}{bal}$ to $0$.

\subsection{Transferring value}
The act of transferring coins between two accounts:
\[
    \tx{transfer}{\field{A}{id}, v}
\]
which will transfer value from the transaction origin $\origin$ to account $A$.

\spec{
    \inputs
    \begin{itemize}
        \item $\field{A}{id}$ is the account id of the \emph{receiver} of the transfer,
        \item $v$ is the value or `balance' to transfer from the origin to the receiver,
            in the smallest denomination.
    \end{itemize}

    \validation
    \begin{itemize}
        \item The transfer balance is positive, or $v \geq 1$,
        \item The origin's balance minus any transaction fee is $\geq v$.
    \end{itemize}
    \outputs
    \begin{itemize}
        \item $v$ is debited from the origin and credited to $A$.
    \end{itemize}
}

\section{Orgs}
An org is a logical grouping of people and projects with common governance
and funds. An org $O$ is a tuple:
\[
    O = \tuple{\field{O}{id}, \field{O}{account},
        \field{O}{members}, \field{O}{projs}, \field{O}{contract}}
\]

\spec{
    \definition
    \begin{itemize}
        \item $\field{O}{id}$ is the globally unique org identifier,
        \item $\field{O}{account}$ is the org account or \emph{fund},
        \item $\field{O}{members}$ is the set of registered org members,
        \item $\field{O}{projs}$ is the set of registered projects under this org,
        \item $\field{O}{contract}$ is the org contract, which governs
            permissions around the org, as well as its fund. It can be
            described as a function:
            \[
                f : \txs \to \{\top, \bot\}
            \]
            where $\txs$ is any transaction $t$ operating on an org, and $\top$
            signifies $t$ is \emph{authorized} to execute by the contract, while
            $\bot$ means it is \emph{unauthorized}.  Note that a transaction
            can be verified and included in the transaction ledger $\txs$ yet
            still be unauthorized to run by the contract
    \end{itemize}}

\subsection{Registering orgs}
\[
    \tx{register-org}{\field{O}{id}, \field{O}{contract}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{O}{id}$ is the unique identifier being registered,
    \item $\field{O}{contract}$ is the initial org contract that includes
        the initial permission set around the org.
\end{itemize}
\validation
\begin{itemize}
    \item $\field{O}{id}$ must be unique, \ie not currently in use,
        between $1$ and $32$ bytes long, and valid \textsf{UTF-8}.
    \item $\field{\alpha}{bal} \geq \deposit{register-org}$.
\end{itemize}
\outputs
\begin{itemize}
    \item $O \in \orgs$, where $O =
        \tuple{\field{O}{id},
            \field{O}{account},
            \{\origin\},
            \varnothing,
            \field{O}{contract}}$
    \item $\field{O}{account} \in \accounts$,
    \item $\field{\alpha}{bal'} = \field{\alpha}{bal} - \deposit{register-org}$.
\end{itemize}}

\subsection{Unregistering orgs}
\[
    \tx{unregister-org}{\field{O}{id}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{O}{id}$ is the identifier of the org being unregistered,
\end{itemize}
\validation
\begin{itemize}
    \item $O \in \orgs$,
    \item $\field{O}{members} = \{\origin\}$, the transaction origin must be the
        only member,
    \item $\field{O}{projs} = \varnothing$, there must be no projects under the
        org,
\end{itemize}
\outputs
\begin{itemize}
    \item $O \notin \orgs$,
    \item $\field{\alpha}{bal'} = \field{\alpha}{bal} + \deposit{register-org} + \field{O}{account_{bal}}$.
\end{itemize}}

\subsection{Registering org members}
\[
    \tx{register-member}{\field{O}{id}, \field{A}{id}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{A}{id}$ is the account id being registered as a member,
    \item $\field{O}{id}$ is the id of the org under which to register $A$,
\end{itemize}
\validation
\begin{itemize}
    \item $O \in \orgs$,
    \item $\field{A}{id}$ must not already be registered under $O$, or $\field{A}{id} \notin \field{O}{members}$
    \item The transaction author is authorized to execute \txname{register-member},
    \item $\alpha_{bal} \geq \deposit{register-member}$.
\end{itemize}
\outputs
\begin{itemize}
    \item $\field{A}{id} \in \field{O}{members}$,
    \item $\alpha_{bal'} = \alpha_{bal} - \deposit{register-member}$.
\end{itemize}}

\subsection{Unregistering org members}
\[
    \tx{unregister-member}{\field{O}{id}, \field{A}{id}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{O}{id}$ is the id of the org under which the member is registered,
    \item $\field{A}{id}$ is the account id of the member being unregistered,
\end{itemize}
\validation
\begin{itemize}
    \item $O \in \orgs$,
    \item $\field{A}{id} \in \field{O}{members}$,
    \item The transaction author is authorized to execute \txname{unregister-member}.
\end{itemize}
\outputs
\begin{itemize}
    \item $\field{A}{id} \notin \field{O}{members}$,
    \item $\alpha_{bal'} = \alpha_{bal} + \deposit{register-member}$.
\end{itemize}}

\subsection{The org contract}
Every org $O$ in the registry has a contract denoted $\field{O}{contract}$.
The way this contract is invoked is through transactions that act on $O$. For
example, the \textsf{fund} transaction (\S\ref{s:fund}) which transfers value
out of a org is always validated by the org contract before it
is authorized to execute.

A contract is made of a set of \emph{rules} that each handle a specific action
relating to the org. In the \textsf{fund} example, the \textsf{fund}
\emph{rule} would be invoked to determine the outcome of the transaction.

\subsection{Updating the org contract}
The act of updating a org's contract:
\[
    \tx{set-contract}{\field{O}{id}, c}
\]

\spec{
    \inputs
    \begin{itemize}
        \item $\field{O}{id}$ is the id of the org,
        \item $c$ is the new contract.
    \end{itemize}
    \validation
    \begin{itemize}
        \item $O \in \orgs$,
        \item The transaction author is authorized to execute \txname{set-contract},
    \end{itemize}
    \outputs
    \begin{itemize}
        \item $\field{O}{contract} = c$
    \end{itemize}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Projects}
A project $P$ is a tuple:
\[
    P = \tuple{\field{P}{id}, \field{P}{org}, \field{P}{k}, \field{P}{proof}, \field{P}{meta}}
\]

\spec{
    \definition
    \begin{itemize}
        \item $\field{P}{id}$ is the unique project identifier within the context of an $\field{P}{org}$,
        \item $\field{P}{org}$ is the org under which this project lives,
        \item $\field{P}{k}$ is the current project \emph{checkpoint} (See \S\ref{s:checkpoint}),
        \item $\field{P}{proof}$ is the proof that was supplied during proposal,
            verifying the owner's authority over the project,
        \item $\field{P}{meta}$ is opaque metadata to associate with $P$. For
            example, the \radicle{} \emph{project id}. Note that once defined, the
            metadata is immutable.
    \end{itemize}}
Projects are registered with the \textsf{register-project} transaction and unregistered
with the \textsf{unregsiter-project} transaction. Projects always exist within the
context of an org.

\subsection{Registering}
\[
    \tx{register-project}{\field{P}{org}, \field{P}{id}, \field{P}{k}, \field{P}{meta}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{P}{id}$ is the unique project id being requested,
    \item $\field{P}{org}$ is the id of the org under which to register $P$,
    \item $\field{P}{k}$ is the id of the initial \emph{checkpoint} associated
        with this project, formally $k_0$. This checkpoint must always remain
        in the project ancestry,
    \item $\field{P}{meta}$ is associated project metadata.
\end{itemize}
\validation
\begin{itemize}
    \item $\field{P}{org}$ identifies an existing org $O$,
    \item $\field{P}{id}$ is unique under $O$, between $1$ and $32$
        bytes long, and valid \textsf{UTF-8}.
    \item $\field{P}{k}$ represents an existing checkpoint,
    \item $\field{P}{meta}$ is $\leq 128$ bytes long,
    \item The transaction author is authorized to execute \txname{register-project},
    \item $\alpha_{bal} \geq \deposit{register-project}$.
\end{itemize}
\outputs
\begin{itemize}
    \item $P \in \field{O}{projs}$, where $\field{O}{id} = \field{P}{org}$,
    \item $\alpha_{bal'} = \alpha_{bal} - \deposit{register-project}$.
\end{itemize}}

\subsection{Unregistering}
\[
    \tx{unregister-project}{\field{P}{org}, \field{P}{id}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{P}{id}$ is the project id being unregistered,
    \item $\field{P}{org}$ is the id of the org under which $P$ lives,
\end{itemize}
\validation
\begin{itemize}
    \item $\field{P}{org}$ identifies an existing org $O$,
    \item $P \in \field{O}{projs}$,
    \item The transaction author is authorized to execute \txname{unregister-project}.
\end{itemize}
\outputs
\begin{itemize}
    \item $P \notin \field{O}{projs}$,
    % TODO: Does the deposit go back to the org account instead?
    \item $\alpha_{bal'} = \alpha_{bal} + \deposit{register-project}$.
\end{itemize}}


\subsection{Checkpointing}
\label{s:checkpoint}
The act of anchoring a project's state and updating the network graph:
\[
    \tx{checkpoint}{\field{K}{parent}, \field{K}{hash}, \field{K}{version},
    \field{K}{contribs}, \field{K}{deps}}
\]
Checkpoints within the scope of a single project form a chain going from the
latest, or ``current'' checkpoint $k_{n-1}$ to the first and original
checkpoint $k_0$. Checkpoints are identified by their transaction hash,
so $k \in \field{T}{hash}$.

From the perspective of $k_0$, we can talk of a checkpoint \emph{tree}, since
due to their nature, they are able to represent branching. Hence, the original
checkpoint $k_0$ is also called the \emph{root} checkpoint.

\inputs
\begin{itemize}
    \item $\field{K}{parent}$ is the \emph{id} of the previous or `parent' checkpoint,
    \item $\field{K}{hash}$ is the new hash of the project state,
    \item $\field{K}{version}$ is the current version of the project,
    \item $\field{K}{contribs}$ is the list of contributions since $\field{K}{parent}$,
    \item $\field{K}{deps}$ is the list of dependency updates since the $\field{K}{parent}$.
\end{itemize}
\validation
\begin{itemize}
    \item{$\field{K}{parent}$ refers to an existing checkpoint in the registry,
        or is $\varnothing$.}
    \item{$\field{K}{hash}$ is a valid hash that hasn't been used in a parent
        checkpoint.}
    \item{$\field{K}{version}$ is a string between $1$ and $32$ bytes long that
        \emph{may} have been used in a previous project checkpoint.}
    \item{$\field{K}{contribs}$ is a valid contribution list (See \S
        \ref{s:checkpoint-contribs}).}
    \item{$\field{K}{deps}$ is a valid dependency update list (See \S
        \ref{s:checkpoint-deps}).}
\end{itemize}

\subsection{Contributions}
\label{s:checkpoint-contribs}
The list $\field{K}{contribs}$ supplied to the $\mathsf{checkpoint}$
transaction is of the form:

\[
    \field{K}{contribs} = [\tuple{\field{C}{parent}, \field{C}{hash},
    \field{C}{author}, \field{C}{sig}}],
\]

\spec{
    \definition
    \begin{itemize}
        \item $\field{C}{parent}$ is the hash of the parent contribution, or
            $\varnothing$ if this is the first contribution of the first checkpoint
            of the project.
        \item $\field{C}{hash}$ is the hash of the corresponding commit,
        \item $\field{C}{author}$ is the public signing key of the commit referred
            to by $C$,
        \item $\field{C}{sig}$ is the author's \textsf{GPG} signature.
    \end{itemize}
    \validation
    \begin{itemize}
        \item $\field{C}{parent}$ is a valid \textsf{SHA-1} hash or
            $\varnothing$ if this is the first contribution. Note that if $C$
            is $\field{K}{contribs}$'s first item, and $C'$ is the \emph{last}
            item of the \emph{parent} checkpoint's contributions list, then
            $\field{C'}{hash}$ and $\field{C}{parent}$ must be equal, such that
            no gaps between contributions exist.

        \item $\field{C}{hash}$ is a valid \textsf{SHA-1} hash,
        \item $\field{C}{author}$ is the creator of $\field{C}{sig}$,
        \item $\field{C}{sig}$ is a valid signature of $\field{C}{hash}$.
    \end{itemize}
}
Because all changes to a project's source code are described in checkpoints, it
is possible to reconstruct a full hash-linked list of contributions for the
entire project. When cross-referenced with the project's repository, this
constitutes a complete historical record of who authored what code. This
ensures the project history is auditable and tamper-proof, while providing
fundamental information to for the network graph $\netgraph$. Note that only
contribution \emph{metadata} is stored on-chain.

\subsection{Dependency updates}
\label{s:checkpoint-deps}
Conceptually, a project $P$ depends on another project $P'$ if it is an
``input'' to $P$ in some way: $P$ references $P'$ or parts of $P'$ in its
source code, or $P'$ is a build/test dependency.

The dependency update list $\field{P}{deps}$ is a list of \emph{dependency
  updates}, one of:
\[
    \begin{cases}
        \depend(\field{P'}{id}, \field{P'}{version}) \\
        \undepend(\field{P'}{id}, \field{P'}{version})
    \end{cases}
\]
which refer to the project $P'$ at a specific version $\field{P'}{version}$.
The $\depend$ update adds a new dependency while the $\undepend$ update removes
a dependency. The updates are processed in order with $\depend$ only being
valid if it adds a dependency that the project does not already have and
$\undepend$ only being valid for current dependencies. The checkpoint is
invalid if the update list contains duplicates.

% NOTE: Should the checkpoints include the hash of the project being depended
% on? This would add another check for projects registering.

\bigskip
\validation
\begin{itemize}
    \item $\field{P'}{id}$ must be a valid project id, but \emph{does not}
        have to refer to an existing id in the registry. This allows dependent
        projects to checkpoint dependencies that have not yet been registered.
    \item $\field{P'}{version}$ must be a valid version string, but \emph{does not}
        have to refer to an existing version of $P'$. This allows dependent projects
        to checkpoint before their dependencies.
\end{itemize}
As a project maintainer, adding a dependency signals a variety of things
depending of the nature of the project:
\begin{itemize}
\item They have verified that $P$ indeed depends on this specific
  version of $P'$.
\item That $P'$ is suitable as a dependency for $P$, \eg{} if $P$ has
  very high security requirements, that $P'$ fulfills these.
\end{itemize}
\noindent Since contributions to a project carry additional
weight---potentially increasing a project's rank---there is an incentive
for maintainers to checkpoint their projects regularly.  Similarly, adding
dependencies may increase connectivity in the network graph, which may in turn
indirectly improve a project's rank.

\subsection{Setting the project checkpoint}
The act of updating the project to point to a new checkpoint:
\[
    \tx{set-checkpoint}{\field{P}{id}, k'}
\]
which updates $\field{P}{checkpoint}$ from $k$ to $k'$.

\spec{
    \inputs
    \begin{itemize}
        \item $\field{P}{id}$ is the id of the project being updated,
        \item $k'$ is the id of the checkpoint the project
            should be associated to.
    \end{itemize}
    \validation
    \begin{itemize}
        \item $\field{P}{id}$ refers to a project that has been accepted
            in the registry,
        \item $k'$ is a checkpoint which has the original project checkpoint
            $k_0$ in its ancestry.
        \item $\field{P}{contract}(\txmsg{set-checkpoint}{\field{P}{id}, k'}) \equiv \top$
    \end{itemize}
    \outputs
    \begin{itemize}
        \item $\field{P}{k} = k'$
    \end{itemize}}
Note that the semantics of this transaction allows for projects to revert to
a previous checkpoint, or to adopt a ``fork'', as long as the new checkpoint
shares part of its ancestry with the previous checkpoint.

\subsection{The project fund}
\label{s:fund}
Each project has an associated account $\field{P}{account}$ called the
\emph{fund}. To use that account to fund maintenance or other projects,
the \textsf{fund} transaction is used:
\[
    \tx{fund}{\field{P}{id}, \field{A}{id}, v}
\]

\spec{
    \inputs
    \begin{itemize}
        \item $\field{P}{id}$ is the id of the project that should initiate
            the value transfer.
        \item $\field{A}{id}$ is the id of the account that should receive
            the value.
        \item $v$ is the value being transfered.
    \end{itemize}
    \validation
    \begin{itemize}
        \item $\field{p}{bal} \geq v$, where $p = \field{P}{account}$,
        % TODO: Update this if we have deposits.
        \item $\field{P}{contract}(\txmsg{fund}{\field{P}{id}, \field{A}{id}, v}) \equiv \top$.
    \end{itemize}
    \outputs
    \begin{itemize}
        \item $\field{A}{bal'} = \field{A}{bal} + v$
    \end{itemize}}

\section{User Identity}

Identity in the registry serves as a way for users to consolidate the various
keys and external identities they use under a short, human-readable name.

A user $U$ is a logical grouping of {\em identities}, or user identifiers under a
single, unique identifier, $\field{U}{id}$. The set of all users is $\users$.
\[
    U = \tuple{\field{U}{id}, \field{U}{account}, \field{U}{keys}}
\]
\spec{
    \definition
    \begin{itemize}
        \item $\field{U}{id}$ is the globally unique human-readable identifier of the user,
        \item $\field{U}{account}$ is the account id which owns this user identity,
        \item $\field{U}{keys}$ is the set of off-registry public keys associated
            with this identity.
    \end{itemize}}

\subsection{Registering}
We register a new user identity and thus user
\[
    \tx{register-identity}{\field{U}{id}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{U}{id}$ is the gobally unique user identifier being registered,
\end{itemize}
\validation
\begin{itemize}
    \item $\field{U}{id}$ must be unique, \ie not currently in use,
        between $1$ and $32$ bytes long, and valid \textsf{UTF-8}.
    \item $\field{\alpha}{bal} \geq \deposit{register-identity}$.
\end{itemize}
\outputs
\begin{itemize}
    \item $U \in \users$, where $U = \tuple{\field{U}{id}, \field{\origin}{id}, \varnothing}$
    \item $\field{\alpha}{bal'} = \field{\alpha}{bal} - \deposit{register-identity}$
\end{itemize}}

\subsection{Unregistering}
\[
    \tx{unregister-identity}{\field{U}{id}}
\]

\spec{
\inputs
\begin{itemize}
    \item $\field{U}{id}$ is the identity being unregistered,
\end{itemize}
\validation
\begin{itemize}
    \item $U \in \users$,
    \item $\origin$ must be the owner of this identity, in other words $\field{U}{account} \equiv \field{\origin}{id}$,
\end{itemize}
\outputs
\begin{itemize}
    \item $U \notin \users$,
    \item $\field{\origin}{bal'} = \field{\origin}{bal} + \deposit{register-identity}$.
\end{itemize}}

\subsection{Associating an external key}
The act of associating an external public key to a registered user identity:
\[
    \tx{associate-key}{\field{U}{id}, k, \pi}
\]

\spec{
    \inputs
    \begin{itemize}
        \item $\field{U}{id}$ is the identity under which to associate the key,
        \item $k$ is the public portion of the key pair $\tuple{k, S_k}$ that is to be
            associated,
        \item $\pi$ is a proof or signature verifying that the transaction
            author owns $k$, defined as:
            \[
                \pi = \mathsf{encrypt(hash(\mathit{\field{U}{id}}), \mathit{S_k})}
            \]
            where $S_k$ is the secret key from which $k$ was derived.
    \end{itemize}
    \validation
    \begin{itemize}
        \item $k \notin \field{U}{keys}$,
        \item $k$ is a valid $32$ byte \textsf{Ed25519} key,
        \item $\field{\origin}{id} \equiv \field{U}{account}$,
        \item $\mathsf{decrypt}(\pi, k) \equiv \mathsf{hash(\mathit{\field{U}{id}})}$
    \end{itemize}
    \outputs
    \begin{itemize}
        \item $k \in \field{U}{keys}$
    \end{itemize}}

\subsection{Revoking an associated key}
When a public key associated with the \textsf{associate-key} transaction is lost or no
longer used, the following transaction will `revoke' the association:
\[
    \tx{revoke-key}{\field{U}{id}, k}
\]

\spec{
    \inputs
    \begin{itemize}
        \item $\field{U}{id}$ is the identity under which the key is currently associated,
        \item $k$ is the key being revoked,
    \end{itemize}
    \validation
    \begin{itemize}
        \item $k \in \field{U}{keys}$,
        \item $\field{\origin}{id} \equiv \field{U}{account}$,
    \end{itemize}
    \outputs
    \begin{itemize}
        \item $k \notin \field{U}{keys}$
    \end{itemize}}
